아래는 **AI 코딩(프롬프트 → 구현)에도 바로 쓰기 좋게** “서비스 명세”를 구조화한 문서예요. 지금 범위는 **발화 기반 + 타임스탬프 근거 + 요약 + (가능 시) 이벤트 기반 질의**까지이고, **채팅/하이라이트는 제외**예요.

---

## 0. 문서 목적

* 스트리머 VOD를 “시간 기반 검색 가능한 지식 베이스”로 변환해 **웹 챗봇 서비스**로 제공해요.
* 구현 시 모호함을 줄이기 위해 **기능 범위, 데이터 단위, API 계약, 검색 전략**을 명확히 정의해요.

---

## 1. 서비스 개요

### 1.1 서비스 한 줄 정의

* 스트리머 VOD의 발화를 인덱싱해, 사용자가 질문하면 **정확한 타임스탬프 근거**와 함께 답하고, 방송 내용을 **구조화 요약**해주는 서비스예요.

### 1.2 핵심 가치

* 긴 방송을 전부 보지 않아도 특정 발언/주제를 **즉시 찾고 확인**할 수 있어요.
* 답변이 반드시 **재생 가능한 근거(타임스탬프)**를 포함해서 신뢰성이 있어요.

---

## 2. 사용자/페르소나

### P1. 팬(일반 사용자)

* “그때 뭐라고 했더라?”, “어제 방송 요약” 니즈

### P2. 아카이브/운영자(스트리머/매니저)

* 방송 기록/공지/발언을 빠르게 찾고 정리하는 니즈

---

## 3. 범위(Scope)

### 3.1 포함(In Scope)

1. **타임스탬프 기반 Q&A**
2. **방송 요약(챕터/목차형)**
3. **근거 보기(발화 스니펫, 앞뒤 맥락)**
4. **스트리머/방송/날짜 필터 기반 검색**
5. (옵션) **이벤트 기반 질의**(예: “10연승 언제?”)

   * 구현 수준에 따라:

     * MVP: 발화에서 “주장/언급”이 있을 때만 처리(Claim-based)
     * 확장: 화면 기반 결과(UI) 추출 등으로 실제 계산

### 3.2 제외(Out of Scope)

* 채팅 데이터 싱크/분석
* 자동 하이라이트/클립 추천
* 감정 피크/반응 폭발 구간 추출

---

## 4. 핵심 기능 명세

### 4.1 기능 F1: 타임스탬프 기반 Q&A

**입력**

* 사용자 질문(자연어)
* 컨텍스트(선택): streamer_id, vod_id, date_range

**출력(필수)**

* answer: 1~5문장 요약 답변
* citations: 타임스탬프 근거 리스트(최소 1개, 권장 3~5개)

  * 각 citation: `vod_id`, `start_sec`, `end_sec`, `snippet`, `confidence`

**동작 조건**

* 답변 생성은 **근거 세그먼트가 존재할 때만 확정 표현**을 사용해요.
* 근거가 부족하면:

  * “근거가 부족해 확정하기 어렵다” + “관련 가능 구간” 또는 “추가 조건 요청” 형태로 응답해요.

**수용 기준(AC)**

* 사용자가 타임스탬프를 클릭하면 해당 구간 재생이 가능해야 해요.
* citations 없이 답변만 반환하는 응답은 실패로 간주해요.

---

### 4.2 기능 F2: 방송 요약(챕터형)

**입력**

* target: vod_id (또는 date_range + streamer_id)
* summary_type: `overall | chapter | topic`

**출력**

* summary_overall (선택): 전체 요약
* chapters (필수): 챕터 리스트

  * 각 chapter: `title`, `start_sec`, `end_sec`, `bullets(3~7개)`, `key_quotes(0~3개)`

**동작 조건**

* 챕터는 기본적으로 3~12개 정도로 제한해요(너무 많으면 가독성 저하).

**수용 기준**

* 각 챕터는 재생 가능한 타임스탬프 범위를 가져야 해요.

---

### 4.3 기능 F3: 근거 보기/맥락 보기

**입력**

* citation_id 또는 (vod_id, timestamp)
* window: `±30s | ±60s | ±120s`

**출력**

* context_snippets: 앞뒤 발화 스니펫
* optional: 간단 맥락 요약(2~4문장)

---

### 4.4 기능 F4: 필터/라이브러리

**필터 종류**

* streamer_id (필수 수준)
* date_range (선택)
* vod_id (선택)
* tag/game/category (선택)

**효과**

* 단순 UX가 아니라 **검색 범위 축소(정확도/속도/비용 개선)**를 위한 시스템 필터로 동작해야 해요.
* date_range는 LLM 추론에 맡기지 않고 가능하면 **metadata 필터로 적용**해요.

---

### 4.5 기능 F5(옵션): 이벤트 기반 질의

**대상 질문 예**

* “10연승 언제야?”, “연승 끊긴 날?”, “몇 판 했어?”

**데이터 원천**

* MVP: transcript에서 이벤트 주장(숫자, 연승, 승패 언급) 추출(Claim)
* 확장: 화면 기반 결과 UI 추출 또는 외부 전적 연동(가능하면)

**출력**

* event_result: 계산/검출된 이벤트 timestamp 리스트
* evidence: 해당 시점 주변 발화 스니펫(가능한 경우)

**수용 기준**

* 이벤트가 “추정/주장”인지 “계산/확정”인지 구분 표시해야 해요.

---

## 5. 검색/RAG 전략 명세

### 5.1 지식 단위(Knowledge Units)

* 기본 세그먼트: 20~60초(권장 30~45초)
* 각 세그먼트는 다음을 가질 수 있어요:

  * transcript_text (원문)
  * note_text (정규화/요약/엔티티 포함)
  * metadata: streamer_id, vod_id, date, start/end sec, tags

### 5.2 멀티 인덱스(논리적)

* Vector 문서 유형(type):

  * `transcript` : 원문 발화 검색용
  * `note` : 의미 정규화/요약 기반 검색용
* Event는 벡터가 아니라 **RDB 테이블**로 관리하는 걸 기본으로 해요.

### 5.3 Query Routing / Search Plan

* 입력 질문을 기반으로 검색 계획을 만들어요.

**Search Plan 예**

```json
{
  "use_event": false,
  "use_vector_types": ["note", "transcript"],
  "filters": {
    "streamer_id": "abc",
    "date_gte": "2026-02-01",
    "date_lte": "2026-02-12",
    "vod_id": null
  }
}
```

**라우팅 구현**

* 1차: 룰 기반(키워드/패턴)으로 빠르게 분기
* 2차: 애매하면 LLM 분류(JSON/툴콜)로 Search Plan 생성

### 5.4 Retrieval 절차(표준)

1. metadata 필터 적용(가능하면)
2. note 인덱스에서 top_k 검색
3. 필요 시 transcript 인덱스로 보강 검색
4. (옵션) rerank
5. 근거 세그먼트로 답변 생성(반드시 citations 포함)

---

## 6. 데이터 파이프라인 명세

### 6.1 인입

* 대상: 유튜브 다시보기 링크(또는 다운로드된 파일)
* 입력 메타: streamer_id, vod_id, 방송일자, 제목

### 6.2 처리 단계

1. audio 추출
2. ASR(음성→텍스트)
3. 세그먼트 분할(시간 단위 또는 발화 단위)
4. note 생성(요약/엔티티/정규화)
5. 임베딩 생성
6. 벡터 저장 + 메타데이터 저장
7. (옵션) 이벤트 추출 저장

### 6.3 산출물

* transcript segments
* note documents
* embeddings
* (옵션) event rows

---

## 7. API 명세(초안)

### 7.1 질의

* `POST /chat/query`

  * req: `{query, streamer_id?, vod_id?, date_range?}`
  * res: `{answer, citations[], followups[]}`

### 7.2 근거 상세

* `GET /vod/{vod_id}/context?ts=...&window=60`

  * res: `{snippets[], summary?}`

### 7.3 요약

* `POST /vod/{vod_id}/summary`

  * req: `{summary_type}`
  * res: `{chapters[], overall?}`

### 7.4 라이브러리

* `GET /streamers`
* `GET /vods?streamer_id=...&date_range=...`

---

## 8. UI 명세(최소)

### 8.1 화면 구성

* 좌: 스트리머/방송 리스트 + 날짜 필터
* 중: 챗(질문/응답/후속 질문)
* 우: 플레이어 + 타임라인(타임스탬프 클릭 점프)

### 8.2 필수 UI 요소

* “근거 보기”
* “앞뒤 맥락 보기(±60s)”
* “이 답변이 맞나요?”(피드백)

---

## 9. 비기능 요구사항(NFR)

* 응답 시간: 일반 질의 3~8초 내(캐시/인덱스 최적화 전제)
* 신뢰성: citations 없는 답변 금지
* 비용: 요약/자주 묻는 질문 캐시 가능 구조
* 로깅: 실패 케이스(근거 없음/라우팅 오류/ASR 품질) 저장

---

## 10. MVP 단계 정의

### MVP-1 (권장)

* transcript + note 인덱스 기반 Q&A
* 방송 챕터 요약
* 필터(스트리머, 날짜, 방송)
* 근거/맥락 보기 + 피드백

### MVP-2 (선택)

* claim 기반 이벤트(“10연승” 발화 언급만)
* 이벤트는 “추정/주장” 라벨 표시

### MVP-3 (확장)

* 화면 기반 이벤트 추출(승/패 등)로 실제 계산

---

원하면, 이 명세를 그대로 코드 생성에 쓰기 좋게 **“작업 티켓(백로그) 형태”**로 쪼개서

* DB 스키마/DDL
* 엔드포인트별 입출력 스키마(JSON Schema)
* 파이프라인 태스크(Airflow DAG 단계)
  까지 한 번에 내려드릴게요.
